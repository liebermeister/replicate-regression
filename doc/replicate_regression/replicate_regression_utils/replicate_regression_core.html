<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of replicate_regression_core</title>
  <meta name="keywords" content="replicate_regression_core">
  <meta name="description" content="[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">replicate_regression</a> &gt; <a href="#">replicate_regression_utils</a> &gt; replicate_regression_core.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for ./replicate_regression/replicate_regression_utils&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>replicate_regression_core
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [result, parameters, options, sample] = replicate_regression_core(t,y,sigma,r,tt,options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)

 Bayesian replicate regression for single time series with multiple replicates

 DESCRIPTION
  Interpolation of multiple time series data from nr replicate experiments
  The regression functions are represented by linear combinations of basis functions (e.g. Fourier components)
  The expansion coefficients (=model parameters) given prior distributions and estimated by taking the posterior mode

 FUNCTION ARGUMENTS
  Each data point is a quadruple [t(i), y(i), sigma(i), r(i)] of 
   - time point t(i) 
   - measured value y(i) 
   - standard deviation (error bar) sigma(i)
   - replicate label r(i) (values from 1,..,nr)

  In this script, the function arguments t, y, sigma, r 
  are given as ROW vectors (or as matrices, where each row is treated separately)

 FUNCTION OUTPUTS 
   Row vectors of regression curves:
    'x_central'  central regression curves
    'x_average'  regression curve averaged over replicates
    'x_replicate' regression curves for the individual replicates 

   and the corresponding uncertainties (row vectors):
    'sigma_central', 'sigma_average', and 'sigma_replicate'

  'parameters' is a structure array containing the estimated parameter values 
        (to be used for statistical evaluation of the prior hyperparameters)

  'x_fit' contains the replicate regression curves, evaluated at the point of original data points
  'x_sample' is a vector of predicted data, obtained from a random sample from the posterior

 OPTIONS FOR THE ALGORITHM
  Detailed options are given the function argument 'p', 
  a structure array with (optional) fields: 

    options.basis                 : type of basis functions
    options.use_offset            : (Boolean) flag for stating that there is a constant basis function
    options.remove_offset         : (Boolean) flag for stating that the constant basis function should be removed
    options.n_comp                : number of Fourier components (not including the constant offset)
                                   (sin and cos for the same wavenumber are counted as one component)
    options.t_jump                : add (at the beginning) a component that yields a constant offset 
    options.t_smooth              : time constant for estimating production rates
    options.constant_before_start : set all basis functions to constant values for negative time values

    options.central_mode_mean    : prior mean for Fourier coefficients alpha for central curve 
                              (vector; same values are used for for sin and cos)
    options.central_offset_mean  : the same (scalar) for the constant basis function (default 1)
    options.central_jump_mean    : the same (scalar) for the jump basis function (default 1)
    options.deviation_mode_mean  : prior mean for Fourier coefficients beta for deviations from central curve
    options.deviation_offset_mean: the same, for the constant basis function (default 1)
    options.deviation_jump_mean  : the same, for the jump basis function (default 1)

    options.central_mode_width    : prior width for Fourier coefficients alpha for central curve 
                              (vector; same values are used for for sin and cos)
    options.central_offset_width  : the same (scalar) for the constant basis function (default 1)
    options.central_jump_width    : the same (scalar) for the jump basis function (default 1)
    options.deviation_mode_width  : prior width for Fourier coefficients beta for deviations from central curve
    options.deviation_offset_width: the same, for the constant basis function (default 1)
    options.deviation_jump_width  : the same, for the jump basis function (default 1)

    options.average_std           : how is the uncertainty of the average curve computed?
                                    'std_dev_mean':  standard deviation of the mean
                                    'curve_spread':  standard deviation of the individual curves
    options.flag_draw_sample      : Draw sample curve parameters and curve from the posterior
    options.flag_time_derivative : Compute time derivative curves
 

  The basis functions are adjusted to the final time interval [ta,tb](from tt)
    'cos'            : cosine function, zero slope at t=ta and t=tb
    'sin'            : sine function, zero value at t=ta and t=tb
    'sin_half'       : sine function, zero value at t=ta
    'sin_horizontal' : sine function, zero value at t=ta, zero slope at t=tb
    'cos+sin'        : cosine and sine functions, no restriction
    'polynomial'     : polynomial function, zero value at t=ta
    'exp'            : exponentially relaxing functions (t&lt;0 =&gt; f=0; t&gt;0 =&gt; f = 1-exp(t/tau);

  The entire curves are shifted by a constant basis function 
  This can be suppressed by setting options.use_offset = 1

 For an example, see the m-file demo_replicate_regression_core

 Wolfram Liebermeister (2010)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="replicate_regression_construct_basis.html" class="code" title="function [V, V_reg, W, W_reg] = mr_construct_basis_functions(t,tt,nr,options);">replicate_regression_construct_basis</a>	[V, V_reg, W, W_reg] = mr_construct_basis_functions(t,tt,options);</li><li><a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>	transform a vector (row or column) into a column vector</li><li><a href="../.././replicate_regression/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>	commandstring = default(varname1,defaultvalue1,varname2,defaultvalue2,...)</li><li><a href="../.././replicate_regression/utils/join_struct.html" class="code" title="function c = join_struct(a,b)">join_struct</a>	c = join_struct(a,b)</li><li><a href="../.././replicate_regression/utils/matrix_add_block.html" class="code" title="function M = matrix_add_block(A,B);">matrix_add_block</a>	M = matrix_add_block(A,B);</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../.././demo/demo_replicate_regression/demo_replicate_regression_core.html" class="code" title="">demo_replicate_regression_core</a>	----------------------------------------------------------------</li><li><a href="../.././replicate_regression/replicate_regression.html" class="code" title="function [result, options, offsets] = replicate_regression(t, y, sigma, r, flag_fix_parameters, varargin)">replicate_regression</a>	[result, options] = replicate_regression(t, y, sigma, r, varargin)</li><li><a href="replicate_regression_core_crossvalidation.html" class="code" title="function [result, parameters, options, sample] = replicate_regression_core_crossvalidation(t, y, sigma, r, t_new, flag_single, options);">replicate_regression_core_crossvalidation</a>	[result, parameters, options, sample] = replicate_regression_core_crossvalidation(t, y, sigma, r, t_new, flag_single, options);</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [result, parameters, options, sample] = replicate_regression_core(t,y,sigma,r,tt,options)</a>
0002 
0003 <span class="comment">%[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Bayesian replicate regression for single time series with multiple replicates</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% DESCRIPTION</span>
0008 <span class="comment">%  Interpolation of multiple time series data from nr replicate experiments</span>
0009 <span class="comment">%  The regression functions are represented by linear combinations of basis functions (e.g. Fourier components)</span>
0010 <span class="comment">%  The expansion coefficients (=model parameters) given prior distributions and estimated by taking the posterior mode</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% FUNCTION ARGUMENTS</span>
0013 <span class="comment">%  Each data point is a quadruple [t(i), y(i), sigma(i), r(i)] of</span>
0014 <span class="comment">%   - time point t(i)</span>
0015 <span class="comment">%   - measured value y(i)</span>
0016 <span class="comment">%   - standard deviation (error bar) sigma(i)</span>
0017 <span class="comment">%   - replicate label r(i) (values from 1,..,nr)</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%  In this script, the function arguments t, y, sigma, r</span>
0020 <span class="comment">%  are given as ROW vectors (or as matrices, where each row is treated separately)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% FUNCTION OUTPUTS</span>
0023 <span class="comment">%   Row vectors of regression curves:</span>
0024 <span class="comment">%    'x_central'  central regression curves</span>
0025 <span class="comment">%    'x_average'  regression curve averaged over replicates</span>
0026 <span class="comment">%    'x_replicate' regression curves for the individual replicates</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   and the corresponding uncertainties (row vectors):</span>
0029 <span class="comment">%    'sigma_central', 'sigma_average', and 'sigma_replicate'</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%  'parameters' is a structure array containing the estimated parameter values</span>
0032 <span class="comment">%        (to be used for statistical evaluation of the prior hyperparameters)</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%  'x_fit' contains the replicate regression curves, evaluated at the point of original data points</span>
0035 <span class="comment">%  'x_sample' is a vector of predicted data, obtained from a random sample from the posterior</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% OPTIONS FOR THE ALGORITHM</span>
0038 <span class="comment">%  Detailed options are given the function argument 'p',</span>
0039 <span class="comment">%  a structure array with (optional) fields:</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%    options.basis                 : type of basis functions</span>
0042 <span class="comment">%    options.use_offset            : (Boolean) flag for stating that there is a constant basis function</span>
0043 <span class="comment">%    options.remove_offset         : (Boolean) flag for stating that the constant basis function should be removed</span>
0044 <span class="comment">%    options.n_comp                : number of Fourier components (not including the constant offset)</span>
0045 <span class="comment">%                                   (sin and cos for the same wavenumber are counted as one component)</span>
0046 <span class="comment">%    options.t_jump                : add (at the beginning) a component that yields a constant offset</span>
0047 <span class="comment">%    options.t_smooth              : time constant for estimating production rates</span>
0048 <span class="comment">%    options.constant_before_start : set all basis functions to constant values for negative time values</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%    options.central_mode_mean    : prior mean for Fourier coefficients alpha for central curve</span>
0051 <span class="comment">%                              (vector; same values are used for for sin and cos)</span>
0052 <span class="comment">%    options.central_offset_mean  : the same (scalar) for the constant basis function (default 1)</span>
0053 <span class="comment">%    options.central_jump_mean    : the same (scalar) for the jump basis function (default 1)</span>
0054 <span class="comment">%    options.deviation_mode_mean  : prior mean for Fourier coefficients beta for deviations from central curve</span>
0055 <span class="comment">%    options.deviation_offset_mean: the same, for the constant basis function (default 1)</span>
0056 <span class="comment">%    options.deviation_jump_mean  : the same, for the jump basis function (default 1)</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%    options.central_mode_width    : prior width for Fourier coefficients alpha for central curve</span>
0059 <span class="comment">%                              (vector; same values are used for for sin and cos)</span>
0060 <span class="comment">%    options.central_offset_width  : the same (scalar) for the constant basis function (default 1)</span>
0061 <span class="comment">%    options.central_jump_width    : the same (scalar) for the jump basis function (default 1)</span>
0062 <span class="comment">%    options.deviation_mode_width  : prior width for Fourier coefficients beta for deviations from central curve</span>
0063 <span class="comment">%    options.deviation_offset_width: the same, for the constant basis function (default 1)</span>
0064 <span class="comment">%    options.deviation_jump_width  : the same, for the jump basis function (default 1)</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%    options.average_std           : how is the uncertainty of the average curve computed?</span>
0067 <span class="comment">%                                    'std_dev_mean':  standard deviation of the mean</span>
0068 <span class="comment">%                                    'curve_spread':  standard deviation of the individual curves</span>
0069 <span class="comment">%    options.flag_draw_sample      : Draw sample curve parameters and curve from the posterior</span>
0070 <span class="comment">%    options.flag_time_derivative : Compute time derivative curves</span>
0071 <span class="comment">%</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%  The basis functions are adjusted to the final time interval [ta,tb](from tt)</span>
0074 <span class="comment">%    'cos'            : cosine function, zero slope at t=ta and t=tb</span>
0075 <span class="comment">%    'sin'            : sine function, zero value at t=ta and t=tb</span>
0076 <span class="comment">%    'sin_half'       : sine function, zero value at t=ta</span>
0077 <span class="comment">%    'sin_horizontal' : sine function, zero value at t=ta, zero slope at t=tb</span>
0078 <span class="comment">%    'cos+sin'        : cosine and sine functions, no restriction</span>
0079 <span class="comment">%    'polynomial'     : polynomial function, zero value at t=ta</span>
0080 <span class="comment">%    'exp'            : exponentially relaxing functions (t&lt;0 =&gt; f=0; t&gt;0 =&gt; f = 1-exp(t/tau);</span>
0081 <span class="comment">%</span>
0082 <span class="comment">%  The entire curves are shifted by a constant basis function</span>
0083 <span class="comment">%  This can be suppressed by setting options.use_offset = 1</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% For an example, see the m-file demo_replicate_regression_core</span>
0086 <span class="comment">%</span>
0087 <span class="comment">% Wolfram Liebermeister (2010)</span>
0088 
0089 <span class="comment">% NAMING OF VARIABLES</span>
0090 <span class="comment">%   Quantities concerning the prediction (symbols with a hat ^ in the paper) are denoted by 'pred'</span>
0091 
0092 <span class="comment">%  ------------------------------------------------------------------------------</span>
0093 <span class="comment">% initialisation</span>
0094 
0095 <span class="keyword">if</span> ~length(y),  error(<span class="string">'Empty data vector'</span>); <span class="keyword">end</span>
0096 
0097 eval(<a href="../.././replicate_regression/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>(<span class="string">'options'</span>,<span class="string">'struct'</span>));
0098 eval(<a href="../.././replicate_regression/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>(<span class="string">'tt'</span>,<span class="string">'min(t)+[max(t)-min(t)]*[0:0.1:1]'</span>));
0099 
0100 <span class="comment">% default number of basis functions</span>
0101 <span class="keyword">if</span> ~isfield(options,<span class="string">'n_comp'</span>), options.n_comp = 3; <span class="keyword">end</span> 
0102 <span class="keyword">if</span> strcmp(options.basis,<span class="string">'cos+sin'</span>), 
0103   options.n_comp = 2*options.n_comp;
0104 <span class="keyword">end</span> 
0105 
0106 options_default = struct(<span class="keyword">...</span>
0107     <span class="string">'basis'</span>,<span class="string">'sin_half'</span>, <span class="keyword">...</span>
0108     <span class="string">'use_offset'</span>,             0, <span class="keyword">...</span>
0109     <span class="string">'central_offset_mean'</span>,    0, <span class="keyword">...</span>
0110     <span class="string">'central_mode_mean'</span>,      zeros(options.n_comp,1), <span class="keyword">...</span>
0111     <span class="string">'deviation_offset_mean'</span>,  0, <span class="keyword">...</span>
0112     <span class="string">'deviation_mode_mean'</span>,    zeros(options.n_comp,1), <span class="keyword">...</span>
0113     <span class="string">'central_offset_width'</span>,   1, <span class="keyword">...</span>
0114     <span class="string">'central_mode_width'</span>,     ones(options.n_comp,1), <span class="keyword">...</span>
0115     <span class="string">'deviation_offset_width'</span>, 1, <span class="keyword">...</span>
0116     <span class="string">'deviation_mode_width'</span>,   ones(options.n_comp,1), <span class="keyword">...</span>
0117     <span class="string">'t_jump'</span>,                 nan, <span class="keyword">...</span>
0118     <span class="string">'t_smooth'</span>,               nan, <span class="keyword">...</span>
0119     <span class="string">'constant_before_start'</span>,  1, <span class="keyword">...</span>
0120     <span class="string">'average_std'</span>,            <span class="string">'std_dev_mean'</span>, <span class="keyword">...</span>
0121     <span class="string">'flag_draw_sample'</span>,       1, <span class="keyword">...</span>
0122     <span class="string">'flag_time_derivative'</span>,  0);
0123 
0124 options = <a href="../.././replicate_regression/utils/join_struct.html" class="code" title="function c = join_struct(a,b)">join_struct</a>(options_default,options);
0125 
0126 <span class="keyword">if</span> isfinite(options.t_smooth), options.flag_time_derivative = 1; <span class="keyword">end</span>
0127 <span class="keyword">if</span> length(options.central_mode_width)   ~= options.n_comp, error(<span class="string">'wrong number of prior widths'</span>); <span class="keyword">end</span>
0128 <span class="keyword">if</span> length(options.deviation_mode_width) ~= options.n_comp, error(<span class="string">'wrong number of prior widths'</span>); <span class="keyword">end</span>
0129 <span class="keyword">if</span> length(options.central_mode_mean)    ~= options.n_comp, error(<span class="string">'wrong number of prior means'</span>);  <span class="keyword">end</span>
0130 <span class="keyword">if</span> length(options.deviation_mode_mean)  ~= options.n_comp, error(<span class="string">'wrong number of prior means'</span>);  <span class="keyword">end</span>
0131 
0132 <span class="comment">% make sure time vectors are actually rows</span>
0133 t  = <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(t)';
0134 tt = <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(tt)';
0135 
0136 <span class="comment">% care for missing sigma values</span>
0137 <span class="keyword">if</span> isempty(sigma), sigma = ones(size(y)); <span class="keyword">end</span>
0138 
0139 <span class="comment">% remove missing values from input vectors</span>
0140 y_orig     = y;
0141 ind_finite = find(isfinite(y));
0142 t          = t(ind_finite);
0143 y          = y(ind_finite);
0144 sigma      = sigma(ind_finite);
0145 r          = r(ind_finite);
0146 
0147 nr         = max(r);
0148 
0149 
0150 <span class="comment">% ----------------------------------------------------</span>
0151 <span class="comment">% Build matrices of basis functions</span>
0152 
0153 
0154 [V, V_reg, W, W_reg] = <a href="replicate_regression_construct_basis.html" class="code" title="function [V, V_reg, W, W_reg] = mr_construct_basis_functions(t,tt,nr,options);">replicate_regression_construct_basis</a>(t, tt, nr, options);
0155 
0156 
0157 <span class="comment">% ----------------------------------------------------</span>
0158 <span class="comment">% build complete matrix for all data</span>
0159 
0160 <span class="comment">% has_label{itt}: bit vector indicating which data points belong to replicate itt</span>
0161 
0162 <span class="keyword">for</span> itt = 1:nr,  has_label{itt} = double(r==itt); <span class="keyword">end</span>
0163 
0164 M         = V;
0165 M_reg     = [];
0166 M_average = V_reg;
0167 
0168 <span class="keyword">for</span> itt = 1:nr,
0169   M     = [M, diag(has_label{itt}) * V];
0170   M_reg = <a href="../.././replicate_regression/utils/matrix_add_block.html" class="code" title="function M = matrix_add_block(A,B);">matrix_add_block</a>(M_reg,V_reg);
0171   M_average = [M_average, 1/nr * V_reg];
0172 <span class="keyword">end</span>
0173 
0174 M_reg = [repmat(V_reg,nr+1,1), [zeros(length(tt),size(M_reg,2)); M_reg]];
0175 
0176 
0177 <span class="comment">%  ------------------------------------------------------------------------------</span>
0178 <span class="comment">% construct vectors of prior widths</span>
0179 <span class="comment">% mu_alpha:    vector of prior means for alpha parameters</span>
0180 <span class="comment">% mu_beta:     vector of prior means for beta parameters</span>
0181 <span class="comment">% sigma_alpha: vector of prior widths for alpha parameters</span>
0182 <span class="comment">% sigma_beta:  vector of prior widths for beta parameters</span>
0183 
0184 <span class="keyword">switch</span> options.basis
0185 
0186   <span class="keyword">case</span> {<span class="string">'cos'</span>,<span class="string">'sin'</span>,<span class="string">'sin_half'</span>,<span class="string">'sin_horizontal'</span>,<span class="string">'polynomial'</span>,<span class="string">'exp'</span>},
0187     mu_alpha    = [options.central_offset_mean;  <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_mean)];
0188     sigma_alpha = [options.central_offset_width; <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_width)];
0189     mu_beta     = repmat([options.deviation_offset_mean;  <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_mean)],1,nr);
0190     sigma_beta  = repmat([options.deviation_offset_width; <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_width)],1,nr);
0191 
0192   <span class="keyword">case</span> <span class="string">'cos+sin'</span>, <span class="comment">% duplicate vectors</span>
0193     mu_alpha = [options.central_offset_mean; <span class="keyword">...</span>
0194          reshape([<a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_mean)'; <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_mean)'],2*length(options.central_mode_mean),1)];
0195     mu_beta = repmat([options.deviation_offset_mean; reshape([<a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_mean); <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_mean)],2*length(options.deviation_mode_mean),1)],1,nr);
0196     sigma_alpha = [options.central_offset_width; <span class="keyword">...</span>
0197          reshape([<a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_width)'; <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_width)'],2*length(options.central_mode_width),1)];
0198     sigma_beta = repmat([options.deviation_offset_width; reshape([<a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_width); <a href="../.././replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_width)],2*length(options.deviation_mode_width),1)],1,nr);
0199 <span class="keyword">end</span>
0200 
0201 <span class="keyword">if</span> isfinite(options.t_jump),
0202     mu_alpha    = [mu_alpha;    options.central_jump_mean;];
0203     sigma_alpha = [sigma_alpha; options.central_jump_width;];
0204     mu_beta     = [mu_beta;     options.deviation_jump_mean  * ones(1,nr)];
0205     sigma_beta  = [sigma_beta;  options.deviation_jump_width * ones(1,nr)];
0206 <span class="keyword">end</span>
0207 
0208 mu_beta    = reshape(mu_beta,   prod(size(mu_beta)),1);
0209 sigma_beta = reshape(sigma_beta,prod(size(sigma_beta)),1);
0210 
0211 
0212 <span class="comment">% -----------------------------------------------------</span>
0213 <span class="comment">% Bayesian parameter estimation:</span>
0214 <span class="comment">% 1. compute mean and covariance of coefficients</span>
0215 <span class="comment">% 2. compute mean and covariance of curves per time point</span>
0216 
0217 theta_prior_mean        = [mu_alpha; mu_beta];
0218 theta_prior_cov_inv     = diag(1./[sigma_alpha; sigma_beta].^2);
0219 x_mean                  = y';
0220 x_cov_inv               = diag(1./sigma.^2);
0221 
0222 <span class="comment">% to avoid problems with ill-conditioned posterior covariance matrix:</span>
0223 epsilon = 10^-5; 
0224 
0225 theta_posterior_cov_inv = M' * x_cov_inv * M + theta_prior_cov_inv;
0226 theta_posterior_cov     = inv(theta_posterior_cov_inv + epsilon * eye(size(theta_posterior_cov_inv)) );
0227 theta_posterior_mean    = theta_posterior_cov * [ M' * x_cov_inv * x_mean + theta_prior_cov_inv * theta_prior_mean];
0228 
0229 <span class="comment">%alternative: (avoiding the matrix inversion needed for theta_posterior_cov)</span>
0230 <span class="comment">%theta_posterior_mean    = theta_posterior_cov_inv \ [ M' * x_cov_inv * x_mean];</span>
0231 
0232 <span class="comment">% -----------------------------------------------------</span>
0233 <span class="comment">% curve reconstruction</span>
0234 
0235 x_all     = [ M_reg * theta_posterior_mean ]';
0236 sigma_all = sqrt(diag([ M_reg * theta_posterior_cov * M_reg']))';
0237 
0238 <span class="comment">% central curve and its uncertainty</span>
0239 x_central     = x_all(1:length(tt));
0240 sigma_central = sigma_all(1:length(tt));
0241 
0242 <span class="comment">% average curve and its uncertainty</span>
0243 x_average     = [M_average * theta_posterior_mean]';
0244 
0245 <span class="keyword">switch</span> options.average_std,   
0246   <span class="keyword">case</span> <span class="string">'std_dev_mean'</span>,
0247     <span class="comment">%% consider the standard deviation of the mean:</span>
0248     sigma_average    = sqrt( diag( [ M_average * theta_posterior_cov * M_average'] ) )';
0249   <span class="keyword">case</span>  <span class="string">'curve_spread'</span>,
0250     <span class="comment">%% consider the standard deviation of the individual curves</span>
0251     sigma_average = std(reshape(x_all(length(tt)+1:end),length(tt),nr)');
0252 <span class="keyword">end</span>
0253 
0254 <span class="comment">% individual replicate curves</span>
0255 
0256 <span class="keyword">for</span> itt = 1:nr,
0257   x_replicate{itt} =  x_all(itt*length(tt)+(1:length(tt)));
0258   <span class="keyword">if</span> isempty( x_replicate{itt}),  
0259     x_replicate{itt} = nan * ones(1,length(tt)); 
0260     <span class="keyword">end</span>
0261   sigma_replicate{itt} =  sigma_all(itt*length(tt)+(1:length(tt)));
0262   <span class="keyword">if</span> isempty( sigma_replicate{itt}),  
0263     sigma_replicate{itt} = nan * ones(1,length(tt)); 
0264   <span class="keyword">end</span>
0265 <span class="keyword">end</span>
0266 
0267 <span class="comment">% fitted data points</span>
0268 
0269 x_fit = [ M * theta_posterior_mean ]';
0270 
0271 <span class="comment">% -------------------------------------------------------------------------</span>
0272 <span class="comment">% model parameters</span>
0273 
0274 alpha        = theta_posterior_mean(1:length(sigma_alpha));
0275 beta         = theta_posterior_mean(length(sigma_alpha)+1:end);
0276 beta         = reshape(beta,prod(size(beta))/nr,nr);
0277 
0278 parameters.alpha_offset = alpha(1);
0279 parameters.beta_offset  = beta(1,:);
0280 parameters.alpha        = alpha(2:end);
0281 parameters.beta         = beta(2:<span class="keyword">end</span>,:);
0282 parameters.alpha_jump   = nan;
0283 parameters.beta_jump    = nan;
0284 
0285 <span class="keyword">if</span> isfinite(options.t_jump),
0286  parameters.alpha        = alpha(2:end-1);
0287  parameters.beta         = beta(2:end-1,:);
0288  parameters.alpha_jump   = alpha(end);
0289  parameters.beta_jump    = beta(<span class="keyword">end</span>,:);
0290 <span class="keyword">end</span>
0291 
0292 <span class="comment">% the following entries possibly refer to the logarithmic values</span>
0293 parameters.y            = y;
0294 parameters.sigma        = sigma;
0295 parameters.residuals    = y - x_fit;
0296 
0297 <span class="comment">% if necessary, re-insert missing values into x_fit</span>
0298 dummi = x_fit;
0299 x_fit = y_orig;
0300 x_fit(ind_finite) = dummi;
0301 
0302 <span class="comment">% -------------------------------------------</span>
0303 
0304 result.x_central       = x_central;
0305 result.x_average       = x_average;
0306 result.x_replicate     = x_replicate;
0307 result.sigma_central   = sigma_central;
0308 result.sigma_average   = sigma_average;
0309 result.sigma_replicate = sigma_replicate;
0310 result.x_fit           = x_fit;
0311 result.t               = tt;
0312 
0313 
0314 <span class="comment">% --------------------------------------------</span>
0315 <span class="comment">% sample one parameter set from posterior and compute the corresponding curves</span>
0316 
0317 <span class="keyword">if</span> options.flag_draw_sample,
0318 
0319 theta_sample = theta_posterior_mean + sqrtm(theta_posterior_cov) * randn(size(theta_posterior_mean));
0320 x_sample_all = [M_reg * theta_sample ]';
0321 n_t          = length(result.t);
0322 nr           = max(r);
0323 
0324 sample.x_central    = x_sample_all(1:n_t); 
0325 sample.x_replicate  = reshape(x_sample_all(n_t+1:end),n_t,nr);
0326 sample.x_average    = mean(sample.x_replicate,2);
0327 sample.theta        = theta_sample;
0328 
0329 alpha        = theta_sample(1:length(sigma_alpha));
0330 beta         = theta_sample(length(sigma_alpha)+1:end);
0331 beta         = reshape(beta,prod(size(beta))/nr,nr);
0332 
0333 sample.parameters.alpha_offset = alpha(1);
0334 sample.parameters.beta_offset  = beta(1,:);
0335 sample.parameters.alpha        = alpha(2:end);
0336 sample.parameters.beta         = beta(2:<span class="keyword">end</span>,:);
0337 sample.parameters.alpha_jump   = nan;
0338 sample.parameters.beta_jump    = nan;
0339 
0340 <span class="keyword">if</span> isfinite(options.t_jump),
0341   sample.parameters.alpha        = alpha(2:end-1);
0342   sample.parameters.beta         = beta(2:end-1,:);
0343   sample.parameters.alpha_jump   = alpha(end);
0344   sample.parameters.beta_jump    = beta(<span class="keyword">end</span>,:);
0345 <span class="keyword">end</span>
0346 
0347 <span class="keyword">end</span>
0348 
0349 
0350 <span class="comment">% --------------------------------------------</span>
0351 <span class="comment">% if necessary, compute time derivative and production rate curves</span>
0352 
0353 <span class="keyword">if</span> options.flag_time_derivative
0354   MW         = W;
0355   MW_reg     = [];
0356   MW_average = W_reg;
0357   <span class="keyword">for</span> itt = 1:nr,
0358     MW     = [MW, diag(has_label{itt}) * W];
0359     MW_reg = <a href="../.././replicate_regression/utils/matrix_add_block.html" class="code" title="function M = matrix_add_block(A,B);">matrix_add_block</a>(MW_reg,W_reg);
0360   MW_average = [MW_average, 1/nr * W_reg];
0361   <span class="keyword">end</span>
0362   MW_reg = [repmat(W_reg,nr+1,1), [zeros(length(tt),size(MW_reg,2)); MW_reg]];
0363 <span class="keyword">end</span>
0364 
0365 <span class="keyword">if</span> isfinite(options.t_smooth),
0366   MP         = MW         + 1/options.t_smooth * M        ;
0367   MP_reg     = MW_reg     + 1/options.t_smooth * M_reg    ;
0368   MP_average = MW_average + 1/options.t_smooth * M_average;
0369 <span class="keyword">end</span>
0370 
0371 <span class="comment">% -----------------------------------------------------</span>
0372 <span class="comment">% curve reconstruction (derivatives)</span>
0373 
0374 <span class="keyword">if</span> options.flag_time_derivative
0375 
0376   result.derivative.t = result.t;
0377 result.derivative.x_all                   = [ MW_reg * theta_posterior_mean ]';
0378 result.derivative.sigma_all               = sqrt(diag([ MW_reg * theta_posterior_cov * MW_reg']))';
0379 
0380 <span class="comment">% central curve and its uncertainty</span>
0381 result.derivative.x_central     = result.derivative.x_all(1:length(tt));
0382 result.derivative.sigma_central = result.derivative.sigma_all(1:length(tt));
0383 
0384 <span class="comment">% average curve and its uncertainty</span>
0385 result.derivative.x_average     = [MW_average * theta_posterior_mean]';
0386 
0387 <span class="keyword">switch</span> options.average_std,   
0388   <span class="keyword">case</span> <span class="string">'std_dev_mean'</span>,
0389     <span class="comment">%% consider the standard deviation of the mean:</span>
0390     result.derivative.sigma_average    = sqrt( diag( [ MW_average * theta_posterior_cov * MW_average'] ) )';
0391   <span class="keyword">case</span>  <span class="string">'curve_spread'</span>,
0392     <span class="comment">%% consider the standard deviation of the individual curves</span>
0393     result.derivative.sigma_average = std(reshape(result.derivative.x_all(length(tt)+1:end),length(tt),nr)');
0394 <span class="keyword">end</span>
0395 
0396 <span class="comment">% individual replicate curves</span>
0397 
0398 <span class="keyword">for</span> itt = 1:nr,
0399   result.derivative.x_replicate{itt} =  result.derivative.x_all(itt*length(tt)+(1:length(tt)));
0400   <span class="keyword">if</span> isempty( result.derivative.x_replicate{itt}),  
0401     result.derivative.x_replicate{itt} = nan * ones(1,length(tt)); 
0402     <span class="keyword">end</span>
0403   result.derivative.sigma_replicate{itt} =  result.derivative.sigma_all(itt*length(tt)+(1:length(tt)));
0404   <span class="keyword">if</span> isempty( result.derivative.sigma_replicate{itt}),  
0405     result.derivative.sigma_replicate{itt} = nan * ones(1,length(tt)); 
0406   <span class="keyword">end</span>
0407 <span class="keyword">end</span>
0408 
0409 <span class="keyword">end</span>
0410 
0411 <span class="comment">% -----------------------------------------------------</span>
0412 <span class="comment">% curve reconstruction (production rates)</span>
0413 
0414 <span class="keyword">if</span> isfinite(options.t_smooth),
0415 
0416   result.production.t = result.t;
0417   result.production.x_all                   = [ MP_reg * theta_posterior_mean ]';
0418   result.production.sigma_all               = sqrt(diag([ MP_reg * theta_posterior_cov * MP_reg']))';
0419   
0420 <span class="comment">% central curve and its uncertainty</span>
0421 result.production.x_central     = result.production.x_all(1:length(tt));
0422 result.production.sigma_central = result.production.sigma_all(1:length(tt));
0423 
0424 <span class="comment">% average curve and its uncertainty</span>
0425 result.production.x_average     = [MP_average * theta_posterior_mean]';
0426 
0427 <span class="keyword">switch</span> options.average_std,
0428   <span class="keyword">case</span> <span class="string">'std_dev_mean'</span>,
0429     <span class="comment">%% consider the standard deviation of the mean:</span>
0430     result.production.sigma_average    = sqrt( diag( [ MP_average * theta_posterior_cov * MP_average'] ) )';
0431   <span class="keyword">case</span>  <span class="string">'curve_spread'</span>,
0432     <span class="comment">%% consider the standard deviation of the individual curves</span>
0433     result.production.sigma_average = std(reshape(result.production.x_all(length(tt)+1:end),length(tt),nr)');
0434 <span class="keyword">end</span>
0435 
0436 <span class="comment">% individual replicate curves</span>
0437 
0438 <span class="keyword">for</span> itt = 1:nr,
0439   result.production.x_replicate{itt} =  result.production.x_all(itt*length(tt)+(1:length(tt)));
0440   <span class="keyword">if</span> isempty( result.production.x_replicate{itt}),  
0441     result.production.x_replicate{itt} = nan * ones(1,length(tt)); 
0442     <span class="keyword">end</span>
0443   result.production.sigma_replicate{itt} =  result.production.sigma_all(itt*length(tt)+(1:length(tt)));
0444   <span class="keyword">if</span> isempty( result.production.sigma_replicate{itt}),  
0445     result.production.sigma_replicate{itt} = nan * ones(1,length(tt)); 
0446   <span class="keyword">end</span>
0447 <span class="keyword">end</span>
0448 
0449 <span class="keyword">end</span>
0450 
0451 parameters.basis_functions.basis = options.basis;
0452 parameters.basis_functions.t     = t;
0453 parameters.basis_functions.V     = V;
0454 parameters.basis_functions.W     = W;
0455 parameters.basis_functions.t_reg = tt;
0456 parameters.basis_functions.V_reg = V_reg;
0457 parameters.basis_functions.W_reg = W_reg;
0458</pre></div>
<hr><address>Generated on Sun 09-Nov-2014 11:01:15 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>