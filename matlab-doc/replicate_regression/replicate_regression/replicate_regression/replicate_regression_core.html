<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of replicate_regression_core</title>
  <meta name="keywords" content="replicate_regression_core">
  <meta name="description" content="[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">replicate_regression</a> &gt; <a href="#">replicate_regression</a> &gt; <a href="#">replicate_regression</a> &gt; replicate_regression_core.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for ./replicate_regression/replicate_regression/replicate_regression&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>replicate_regression_core
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [result, parameters, options, sample] = replicate_regression_core(t,y,sigma,r,tt,options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)

 Bayesian replicate regression for single time series with multiple replicates

 DESCRIPTION
  Interpolation of multiple time series data from nr replicate experiments
  The regression functions are represented by linear combinations of basis functions (e.g. Fourier components)
  The expansion coefficients (=model parameters) given prior distributions and estimated by taking the posterior mode

 FUNCTION ARGUMENTS
  Each data point is a quadruple [t(i), y(i), sigma(i), r(i)] of 
   - time point t(i) 
   - measured value y(i) 
   - standard deviation (error bar) sigma(i)
   - replicate label r(i) (values from 1,..,nr)

  In this script, the function arguments t, y, sigma, r 
  are given as ROW vectors (or as matrices, where each row is treated separately)

 FUNCTION OUTPUTS 
   Row vectors of regression curves:
    'x_central'  central regression curves
    'x_average'  regression curve averaged over replicates
    'x_replicate' regression curves for the individual replicates 

   and the corresponding uncertainties (row vectors):
    'sigma_central', 'sigma_average', and 'sigma_replicate'

  'parameters' is a structure array containing the estimated parameter values 
        (to be used for statistical evaluation of the prior hyperparameters)

  'x_fit' contains the replicate regression curves, evaluated at the point of original data points
  'x_sample' is a vector of predicted data, obtained from a random sample from the posterior

 OPTIONS FOR THE ALGORITHM
  Detailed options are given the function argument 'p', 
  a structure array with (optional) fields: 

    options.basis                 : type of basis functions
    options.use_offset            : (Boolean) flag for stating that there is a constant basis function
    options.remove_offset         : (Boolean) flag for stating that the constant basis function should be removed
    options.n_comp                : number of Fourier components (not including the constant offset)
                                   (sin and cos for the same wavenumber are counted as one component)
    options.t_jump                : add (at the beginning) a component that yields a constant offset 
    options.t_smooth              : time constant for estimating production rates
    options.constant_before_start : set all basis functions to constant values for negative time values

    options.central_mode_mean    : prior mean for Fourier coefficients alpha for central curve 
                              (vector; same values are used for for sin and cos)
    options.central_offset_mean  : the same (scalar) for the constant basis function (default 1)
    options.central_jump_mean    : the same (scalar) for the jump basis function (default 1)
    options.deviation_mode_mean  : prior mean for Fourier coefficients beta for deviations from central curve
    options.deviation_offset_mean: the same, for the constant basis function (default 1)
    options.deviation_jump_mean  : the same, for the jump basis function (default 1)

    options.central_mode_width    : prior width for Fourier coefficients alpha for central curve 
                              (vector; same values are used for for sin and cos)
    options.central_offset_width  : the same (scalar) for the constant basis function (default 1)
    options.central_jump_width    : the same (scalar) for the jump basis function (default 1)
    options.deviation_mode_width  : prior width for Fourier coefficients beta for deviations from central curve
    options.deviation_offset_width: the same, for the constant basis function (default 1)
    options.deviation_jump_width  : the same, for the jump basis function (default 1)

    options.average_std           : how is the uncertainty of the average curve computed?
                                    'std_dev_mean':  standard deviation of the mean
                                    'curve_spread':  standard deviation of the individual curves
    options.flag_draw_sample      : Draw sample curve parameters and curve from the posterior
    options.flag_time_derivative : Compute time derivative curves
 

  The basis functions are adjusted to the final time interval [ta,tb](from tt)
    'cos'            : cosine function, zero slope at t=ta and t=tb
    'sin'            : sine function, zero value at t=ta and t=tb
    'sin_half'       : sine function, zero value at t=ta
    'sin_horizontal' : sine function, zero value at t=ta, zero slope at t=tb
    'cos+sin'        : cosine and sine functions, no restriction
    'polynomial'     : polynomial function, zero value at t=ta
    'exp'            : exponentially relaxing functions (t&lt;0 =&gt; f=0; t&gt;0 =&gt; f = 1-exp(t/tau);

  The entire curves are shifted by a constant basis function 
  This can be suppressed by setting options.use_offset = 0

 For an example, see the m-file demo_replicate_regression_core

 Wolfram Liebermeister (2010)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="replicate_regression_construct_basis.html" class="code" title="function [V, V_reg, W, W_reg] = mr_construct_basis_functions(t,tt,nr,options);">replicate_regression_construct_basis</a>	[V, V_reg, W, W_reg] = mr_construct_basis_functions(t,tt,options);</li><li><a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>	transform a vector (row or column) into a column vector</li><li><a href="../../.././replicate_regression/replicate_regression/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>	commandstring = default(varname1,defaultvalue1,varname2,defaultvalue2,...)</li><li><a href="../../.././replicate_regression/replicate_regression/utils/join_struct.html" class="code" title="function c = join_struct(a,b)">join_struct</a>	c = join_struct(a,b)</li><li><a href="../../.././replicate_regression/replicate_regression/utils/matrix_add_block.html" class="code" title="function M = matrix_add_block(A,B);">matrix_add_block</a>	M = matrix_add_block(A,B);</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../.././replicate_regression/replicate_regression.html" class="code" title="function [result, options, offsets] = replicate_regression(t, y, sigma, r, flag_fix_parameters, varargin)">replicate_regression</a>	[result, options] = replicate_regression(t, y, sigma, r, flag_fix_parameters, varargin)</li><li><a href="replicate_regression_core_crossvalidation.html" class="code" title="function [result, parameters, options, sample] = replicate_regression_core_crossvalidation(t, y, sigma, r, t_new, flag_single, options);">replicate_regression_core_crossvalidation</a>	[result, parameters, options, sample] = replicate_regression_core_crossvalidation(t, y, sigma, r, t_new, flag_single, options);</li><li><a href="../../.././replicate_regression/replicate_regression/replicate_regression_demo/demo_replicate_regression_core.html" class="code" title="">demo_replicate_regression_core</a>	----------------------------------------------------------------</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [result, parameters, options, sample] = replicate_regression_core(t,y,sigma,r,tt,options)</a>
0002 
0003 <span class="comment">%[x_central, x_replicate, sigma_central, sigma_replicate, parameters, x_average, sigma_average, x_sample] = replicate_regression_core(t,y,sigma,r,tt,options)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Bayesian replicate regression for single time series with multiple replicates</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% DESCRIPTION</span>
0008 <span class="comment">%  Interpolation of multiple time series data from nr replicate experiments</span>
0009 <span class="comment">%  The regression functions are represented by linear combinations of basis functions (e.g. Fourier components)</span>
0010 <span class="comment">%  The expansion coefficients (=model parameters) given prior distributions and estimated by taking the posterior mode</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% FUNCTION ARGUMENTS</span>
0013 <span class="comment">%  Each data point is a quadruple [t(i), y(i), sigma(i), r(i)] of</span>
0014 <span class="comment">%   - time point t(i)</span>
0015 <span class="comment">%   - measured value y(i)</span>
0016 <span class="comment">%   - standard deviation (error bar) sigma(i)</span>
0017 <span class="comment">%   - replicate label r(i) (values from 1,..,nr)</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%  In this script, the function arguments t, y, sigma, r</span>
0020 <span class="comment">%  are given as ROW vectors (or as matrices, where each row is treated separately)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% FUNCTION OUTPUTS</span>
0023 <span class="comment">%   Row vectors of regression curves:</span>
0024 <span class="comment">%    'x_central'  central regression curves</span>
0025 <span class="comment">%    'x_average'  regression curve averaged over replicates</span>
0026 <span class="comment">%    'x_replicate' regression curves for the individual replicates</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   and the corresponding uncertainties (row vectors):</span>
0029 <span class="comment">%    'sigma_central', 'sigma_average', and 'sigma_replicate'</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%  'parameters' is a structure array containing the estimated parameter values</span>
0032 <span class="comment">%        (to be used for statistical evaluation of the prior hyperparameters)</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%  'x_fit' contains the replicate regression curves, evaluated at the point of original data points</span>
0035 <span class="comment">%  'x_sample' is a vector of predicted data, obtained from a random sample from the posterior</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% OPTIONS FOR THE ALGORITHM</span>
0038 <span class="comment">%  Detailed options are given the function argument 'p',</span>
0039 <span class="comment">%  a structure array with (optional) fields:</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%    options.basis                 : type of basis functions</span>
0042 <span class="comment">%    options.use_offset            : (Boolean) flag for stating that there is a constant basis function</span>
0043 <span class="comment">%    options.remove_offset         : (Boolean) flag for stating that the constant basis function should be removed</span>
0044 <span class="comment">%    options.n_comp                : number of Fourier components (not including the constant offset)</span>
0045 <span class="comment">%                                   (sin and cos for the same wavenumber are counted as one component)</span>
0046 <span class="comment">%    options.t_jump                : add (at the beginning) a component that yields a constant offset</span>
0047 <span class="comment">%    options.t_smooth              : time constant for estimating production rates</span>
0048 <span class="comment">%    options.constant_before_start : set all basis functions to constant values for negative time values</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%    options.central_mode_mean    : prior mean for Fourier coefficients alpha for central curve</span>
0051 <span class="comment">%                              (vector; same values are used for for sin and cos)</span>
0052 <span class="comment">%    options.central_offset_mean  : the same (scalar) for the constant basis function (default 1)</span>
0053 <span class="comment">%    options.central_jump_mean    : the same (scalar) for the jump basis function (default 1)</span>
0054 <span class="comment">%    options.deviation_mode_mean  : prior mean for Fourier coefficients beta for deviations from central curve</span>
0055 <span class="comment">%    options.deviation_offset_mean: the same, for the constant basis function (default 1)</span>
0056 <span class="comment">%    options.deviation_jump_mean  : the same, for the jump basis function (default 1)</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%    options.central_mode_width    : prior width for Fourier coefficients alpha for central curve</span>
0059 <span class="comment">%                              (vector; same values are used for for sin and cos)</span>
0060 <span class="comment">%    options.central_offset_width  : the same (scalar) for the constant basis function (default 1)</span>
0061 <span class="comment">%    options.central_jump_width    : the same (scalar) for the jump basis function (default 1)</span>
0062 <span class="comment">%    options.deviation_mode_width  : prior width for Fourier coefficients beta for deviations from central curve</span>
0063 <span class="comment">%    options.deviation_offset_width: the same, for the constant basis function (default 1)</span>
0064 <span class="comment">%    options.deviation_jump_width  : the same, for the jump basis function (default 1)</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%    options.average_std           : how is the uncertainty of the average curve computed?</span>
0067 <span class="comment">%                                    'std_dev_mean':  standard deviation of the mean</span>
0068 <span class="comment">%                                    'curve_spread':  standard deviation of the individual curves</span>
0069 <span class="comment">%    options.flag_draw_sample      : Draw sample curve parameters and curve from the posterior</span>
0070 <span class="comment">%    options.flag_time_derivative : Compute time derivative curves</span>
0071 <span class="comment">%</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%  The basis functions are adjusted to the final time interval [ta,tb](from tt)</span>
0074 <span class="comment">%    'cos'            : cosine function, zero slope at t=ta and t=tb</span>
0075 <span class="comment">%    'sin'            : sine function, zero value at t=ta and t=tb</span>
0076 <span class="comment">%    'sin_half'       : sine function, zero value at t=ta</span>
0077 <span class="comment">%    'sin_horizontal' : sine function, zero value at t=ta, zero slope at t=tb</span>
0078 <span class="comment">%    'cos+sin'        : cosine and sine functions, no restriction</span>
0079 <span class="comment">%    'polynomial'     : polynomial function, zero value at t=ta</span>
0080 <span class="comment">%    'exp'            : exponentially relaxing functions (t&lt;0 =&gt; f=0; t&gt;0 =&gt; f = 1-exp(t/tau);</span>
0081 <span class="comment">%</span>
0082 <span class="comment">%  The entire curves are shifted by a constant basis function</span>
0083 <span class="comment">%  This can be suppressed by setting options.use_offset = 0</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% For an example, see the m-file demo_replicate_regression_core</span>
0086 <span class="comment">%</span>
0087 <span class="comment">% Wolfram Liebermeister (2010)</span>
0088 
0089 <span class="comment">% NAMING OF VARIABLES</span>
0090 <span class="comment">%   Quantities concerning the prediction (symbols with a hat ^ in the paper) are denoted by 'pred'</span>
0091 
0092 <span class="comment">%  ------------------------------------------------------------------------------</span>
0093 <span class="comment">% initialisation</span>
0094 
0095 <span class="keyword">if</span> ~length(y),  error(<span class="string">'Empty data vector'</span>); <span class="keyword">end</span>
0096 
0097 eval(<a href="../../.././replicate_regression/replicate_regression/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>(<span class="string">'options'</span>,<span class="string">'struct'</span>));
0098 eval(<a href="../../.././replicate_regression/replicate_regression/utils/default.html" class="code" title="function commandstring = default(varargin)">default</a>(<span class="string">'tt'</span>,<span class="string">'min(t)+[max(t)-min(t)]*[0:0.1:1]'</span>));
0099 
0100 <span class="comment">% default number of basis functions</span>
0101 <span class="keyword">if</span> ~isfield(options,<span class="string">'n_comp'</span>), options.n_comp = 3; <span class="keyword">end</span> 
0102 <span class="keyword">if</span> strcmp(options.basis,<span class="string">'cos+sin'</span>), 
0103   options.n_comp = 2*options.n_comp;
0104 <span class="keyword">end</span> 
0105 
0106 options_default = struct(<span class="keyword">...</span>
0107     <span class="string">'basis'</span>,<span class="string">'sin_half'</span>, <span class="keyword">...</span>
0108     <span class="string">'use_offset'</span>,             0, <span class="keyword">...</span>
0109     <span class="string">'central_offset_mean'</span>,    0, <span class="keyword">...</span>
0110     <span class="string">'central_mode_mean'</span>,      zeros(options.n_comp,1), <span class="keyword">...</span>
0111     <span class="string">'deviation_offset_mean'</span>,  0, <span class="keyword">...</span>
0112     <span class="string">'deviation_mode_mean'</span>,    zeros(options.n_comp,1), <span class="keyword">...</span>
0113     <span class="string">'central_offset_width'</span>,   1, <span class="keyword">...</span>
0114     <span class="string">'central_mode_width'</span>,     ones(options.n_comp,1), <span class="keyword">...</span>
0115     <span class="string">'deviation_offset_width'</span>, 1, <span class="keyword">...</span>
0116     <span class="string">'deviation_mode_width'</span>,   ones(options.n_comp,1), <span class="keyword">...</span>
0117     <span class="string">'t_jump'</span>,                 nan, <span class="keyword">...</span>
0118     <span class="string">'t_smooth'</span>,               nan, <span class="keyword">...</span>
0119     <span class="string">'constant_before_start'</span>,  1, <span class="keyword">...</span>
0120     <span class="string">'average_std'</span>,            <span class="string">'std_dev_mean'</span>, <span class="keyword">...</span>
0121     <span class="string">'flag_draw_sample'</span>,       1, <span class="keyword">...</span>
0122     <span class="string">'flag_time_derivative'</span>,  0);
0123 
0124 options = <a href="../../.././replicate_regression/replicate_regression/utils/join_struct.html" class="code" title="function c = join_struct(a,b)">join_struct</a>(options_default,options);
0125 
0126 <span class="keyword">if</span> isfinite(options.t_smooth), options.flag_time_derivative = 1; <span class="keyword">end</span>
0127 <span class="keyword">if</span> length(options.central_mode_width)   ~= options.n_comp, error(<span class="string">'wrong number of prior widths'</span>); <span class="keyword">end</span>
0128 <span class="keyword">if</span> length(options.deviation_mode_width) ~= options.n_comp, error(<span class="string">'wrong number of prior widths'</span>); <span class="keyword">end</span>
0129 <span class="keyword">if</span> length(options.central_mode_mean)    ~= options.n_comp, error(<span class="string">'wrong number of prior means'</span>);  <span class="keyword">end</span>
0130 <span class="keyword">if</span> length(options.deviation_mode_mean)  ~= options.n_comp, error(<span class="string">'wrong number of prior means'</span>);  <span class="keyword">end</span>
0131 
0132 <span class="comment">% make sure time vectors are actually rows</span>
0133 t  = <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(t)';
0134 tt = <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(tt)';
0135 
0136 <span class="comment">% care for missing sigma values</span>
0137 <span class="keyword">if</span> isempty(sigma), sigma = ones(size(y)); <span class="keyword">end</span>
0138 
0139 <span class="comment">% remove missing values from input vectors</span>
0140 y_orig     = y;
0141 ind_finite = find(isfinite(y));
0142 t          = t(ind_finite);
0143 y          = y(ind_finite);
0144 sigma      = sigma(ind_finite);
0145 r          = r(ind_finite);
0146 
0147 nr         = max(r);
0148 
0149 
0150 <span class="comment">% ----------------------------------------------------</span>
0151 <span class="comment">% Build matrices of basis functions</span>
0152 
0153 
0154 [V, V_reg, W, W_reg] = <a href="replicate_regression_construct_basis.html" class="code" title="function [V, V_reg, W, W_reg] = mr_construct_basis_functions(t,tt,nr,options);">replicate_regression_construct_basis</a>(t, tt, nr, options);
0155 
0156 
0157 <span class="comment">% ----------------------------------------------------</span>
0158 <span class="comment">% build complete matrix for all data</span>
0159 
0160 <span class="comment">% has_label{itt}: bit vector indicating which data points belong to replicate itt</span>
0161 
0162 <span class="keyword">for</span> itt = 1:nr,  has_label{itt} = double(r==itt); <span class="keyword">end</span>
0163 
0164 M         = V;
0165 M_reg     = [];
0166 M_average = V_reg;
0167 
0168 <span class="keyword">for</span> itt = 1:nr,
0169   M     = [M, diag(has_label{itt}) * V];
0170   M_reg = <a href="../../.././replicate_regression/replicate_regression/utils/matrix_add_block.html" class="code" title="function M = matrix_add_block(A,B);">matrix_add_block</a>(M_reg,V_reg);
0171   M_average = [M_average, 1/nr * V_reg];
0172 <span class="keyword">end</span>
0173 
0174 M_reg = [repmat(V_reg,nr+1,1), [zeros(length(tt),size(M_reg,2)); M_reg]];
0175 
0176 
0177 <span class="comment">%  ------------------------------------------------------------------------------</span>
0178 <span class="comment">% construct vectors of prior widths</span>
0179 <span class="comment">% mu_alpha:    vector of prior means for alpha parameters</span>
0180 <span class="comment">% mu_beta:     vector of prior means for beta parameters</span>
0181 <span class="comment">% sigma_alpha: vector of prior widths for alpha parameters</span>
0182 <span class="comment">% sigma_beta:  vector of prior widths for beta parameters</span>
0183 
0184 <span class="keyword">switch</span> options.basis
0185 
0186   <span class="keyword">case</span> {<span class="string">'cos'</span>,<span class="string">'sin'</span>,<span class="string">'sin_half'</span>,<span class="string">'sin_horizontal'</span>,<span class="string">'polynomial'</span>,<span class="string">'exp'</span>},
0187     mu_alpha    = [options.central_offset_mean;  <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_mean)];
0188     sigma_alpha = [options.central_offset_width; <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_width)];
0189     mu_beta     = repmat([options.deviation_offset_mean;  <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_mean)],1,nr);
0190     sigma_beta  = repmat([options.deviation_offset_width; <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_width)],1,nr);
0191 
0192   <span class="keyword">case</span> <span class="string">'cos+sin'</span>, <span class="comment">% duplicate vectors</span>
0193     mu_alpha = [options.central_offset_mean; <span class="keyword">...</span>
0194          reshape([<a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_mean)'; <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_mean)'],2*length(options.central_mode_mean),1)];
0195     mu_beta = repmat([options.deviation_offset_mean; reshape([<a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_mean); <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_mean)],2*length(options.deviation_mode_mean),1)],1,nr);
0196     sigma_alpha = [options.central_offset_width; <span class="keyword">...</span>
0197          reshape([<a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_width)'; <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.central_mode_width)'],2*length(options.central_mode_width),1)];
0198     sigma_beta = repmat([options.deviation_offset_width; reshape([<a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_width); <a href="../../.././replicate_regression/replicate_regression/utils/column.html" class="code" title="function x = column(x)">column</a>(options.deviation_mode_width)],2*length(options.deviation_mode_width),1)],1,nr);
0199 <span class="keyword">end</span>
0200 
0201 <span class="keyword">if</span> isfinite(options.t_jump),
0202     mu_alpha    = [mu_alpha;    options.central_jump_mean;];
0203     sigma_alpha = [sigma_alpha; options.central_jump_width;];
0204     mu_beta     = [mu_beta;     options.deviation_jump_mean  * ones(1,nr)];
0205     sigma_beta  = [sigma_beta;  options.deviation_jump_width * ones(1,nr)];
0206 <span class="keyword">end</span>
0207 
0208 mu_beta    = reshape(mu_beta,   prod(size(mu_beta)),1);
0209 sigma_beta = reshape(sigma_beta,prod(size(sigma_beta)),1);
0210 
0211 
0212 <span class="comment">% -----------------------------------------------------</span>
0213 <span class="comment">% Bayesian parameter estimation:</span>
0214 <span class="comment">% 1. compute mean and covariance of coefficients</span>
0215 <span class="comment">% 2. compute mean and covariance of curves per time point</span>
0216 
0217 theta_prior_mean        = [mu_alpha; mu_beta];
0218 theta_prior_cov_inv     = diag(1./[sigma_alpha; sigma_beta].^2);
0219 x_mean                  = y';
0220 x_cov_inv               = diag(1./sigma.^2);
0221 
0222 <span class="keyword">if</span> min(sigma)/max(sigma) &lt; 0.00001,
0223   warning(<span class="string">'Large spread in assumed error bars detected - please check how error bars are computed'</span>);
0224 <span class="keyword">end</span>
0225 
0226 <span class="comment">% to avoid problems with ill-conditioned posterior covariance matrix:</span>
0227 epsilon = 10^-5; 
0228 
0229 theta_posterior_cov_inv = M' * x_cov_inv * M + theta_prior_cov_inv;
0230 theta_posterior_cov     = inv(theta_posterior_cov_inv + epsilon * eye(size(theta_posterior_cov_inv)) );
0231 theta_posterior_mean    = theta_posterior_cov * [ M' * x_cov_inv * x_mean + theta_prior_cov_inv * theta_prior_mean];
0232 
0233 <span class="comment">%alternative: (avoiding the matrix inversion needed for theta_posterior_cov)</span>
0234 <span class="comment">%theta_posterior_mean    = theta_posterior_cov_inv \ [ M' * x_cov_inv * x_mean];</span>
0235 
0236 <span class="comment">% -----------------------------------------------------</span>
0237 <span class="comment">% curve reconstruction</span>
0238 
0239 x_all     = [ M_reg * theta_posterior_mean ]';
0240 sigma_all = sqrt(diag([ M_reg * theta_posterior_cov * M_reg']))';
0241 
0242 <span class="comment">% central curve and its uncertainty</span>
0243 x_central     = x_all(1:length(tt));
0244 sigma_central = sigma_all(1:length(tt));
0245 
0246 <span class="comment">% average curve and its uncertainty</span>
0247 x_average     = [M_average * theta_posterior_mean]';
0248 
0249 <span class="keyword">switch</span> options.average_std,   
0250   <span class="keyword">case</span> <span class="string">'std_dev_mean'</span>,
0251     <span class="comment">%% consider the standard deviation of the mean:</span>
0252     sigma_average    = sqrt( diag( [ M_average * theta_posterior_cov * M_average'] ) )';
0253   <span class="keyword">case</span>  <span class="string">'curve_spread'</span>,
0254     <span class="comment">%% consider the standard deviation of the individual curves</span>
0255     sigma_average = std(reshape(x_all(length(tt)+1:end),length(tt),nr)');
0256 <span class="keyword">end</span>
0257 
0258 <span class="comment">% individual replicate curves</span>
0259 
0260 <span class="keyword">for</span> itt = 1:nr,
0261   x_replicate{itt} =  x_all(itt*length(tt)+(1:length(tt)));
0262   <span class="keyword">if</span> isempty( x_replicate{itt}),  
0263     x_replicate{itt} = nan * ones(1,length(tt)); 
0264     <span class="keyword">end</span>
0265   sigma_replicate{itt} =  sigma_all(itt*length(tt)+(1:length(tt)));
0266   <span class="keyword">if</span> isempty( sigma_replicate{itt}),  
0267     sigma_replicate{itt} = nan * ones(1,length(tt)); 
0268   <span class="keyword">end</span>
0269 <span class="keyword">end</span>
0270 
0271 <span class="comment">% fitted data points</span>
0272 
0273 x_fit = [ M * theta_posterior_mean ]';
0274 
0275 <span class="comment">% -------------------------------------------------------------------------</span>
0276 <span class="comment">% model parameters</span>
0277 
0278 alpha        = theta_posterior_mean(1:length(sigma_alpha));
0279 beta         = theta_posterior_mean(length(sigma_alpha)+1:end);
0280 beta         = reshape(beta,prod(size(beta))/nr,nr);
0281 
0282 parameters.alpha_offset = alpha(1);
0283 parameters.beta_offset  = beta(1,:);
0284 parameters.alpha        = alpha(2:end);
0285 parameters.beta         = beta(2:<span class="keyword">end</span>,:);
0286 parameters.alpha_jump   = nan;
0287 parameters.beta_jump    = nan;
0288 
0289 <span class="keyword">if</span> isfinite(options.t_jump),
0290  parameters.alpha        = alpha(2:end-1);
0291  parameters.beta         = beta(2:end-1,:);
0292  parameters.alpha_jump   = alpha(end);
0293  parameters.beta_jump    = beta(<span class="keyword">end</span>,:);
0294 <span class="keyword">end</span>
0295 
0296 <span class="comment">% the following entries possibly refer to the logarithmic values</span>
0297 parameters.y            = y;
0298 parameters.sigma        = sigma;
0299 parameters.residuals    = y - x_fit;
0300 
0301 <span class="comment">% if necessary, re-insert missing values into x_fit</span>
0302 dummi = x_fit;
0303 x_fit = y_orig;
0304 x_fit(ind_finite) = dummi;
0305 
0306 <span class="comment">% -------------------------------------------</span>
0307 
0308 result.x_central       = x_central;
0309 result.x_average       = x_average;
0310 result.x_replicate     = x_replicate;
0311 result.sigma_central   = sigma_central;
0312 result.sigma_average   = sigma_average;
0313 result.sigma_replicate = sigma_replicate;
0314 result.x_fit           = x_fit;
0315 result.t               = tt;
0316 
0317 
0318 <span class="comment">% --------------------------------------------</span>
0319 <span class="comment">% sample one parameter set from posterior and compute the corresponding curves</span>
0320 
0321 <span class="keyword">if</span> options.flag_draw_sample,
0322 
0323 theta_sample = theta_posterior_mean + sqrtm(theta_posterior_cov) * randn(size(theta_posterior_mean));
0324 x_sample_all = [M_reg * theta_sample ]';
0325 n_t          = length(result.t);
0326 nr           = max(r);
0327 
0328 sample.x_central    = x_sample_all(1:n_t); 
0329 sample.x_replicate  = reshape(x_sample_all(n_t+1:end),n_t,nr);
0330 sample.x_average    = mean(sample.x_replicate,2);
0331 sample.theta        = theta_sample;
0332 
0333 alpha        = theta_sample(1:length(sigma_alpha));
0334 beta         = theta_sample(length(sigma_alpha)+1:end);
0335 beta         = reshape(beta,prod(size(beta))/nr,nr);
0336 
0337 sample.parameters.alpha_offset = alpha(1);
0338 sample.parameters.beta_offset  = beta(1,:);
0339 sample.parameters.alpha        = alpha(2:end);
0340 sample.parameters.beta         = beta(2:<span class="keyword">end</span>,:);
0341 sample.parameters.alpha_jump   = nan;
0342 sample.parameters.beta_jump    = nan;
0343 
0344 <span class="keyword">if</span> isfinite(options.t_jump),
0345   sample.parameters.alpha        = alpha(2:end-1);
0346   sample.parameters.beta         = beta(2:end-1,:);
0347   sample.parameters.alpha_jump   = alpha(end);
0348   sample.parameters.beta_jump    = beta(<span class="keyword">end</span>,:);
0349 <span class="keyword">end</span>
0350 
0351 <span class="keyword">end</span>
0352 
0353 
0354 <span class="comment">% --------------------------------------------</span>
0355 <span class="comment">% if necessary, compute time derivative and production rate curves</span>
0356 
0357 <span class="keyword">if</span> options.flag_time_derivative
0358   MW         = W;
0359   MW_reg     = [];
0360   MW_average = W_reg;
0361   <span class="keyword">for</span> itt = 1:nr,
0362     MW     = [MW, diag(has_label{itt}) * W];
0363     MW_reg = <a href="../../.././replicate_regression/replicate_regression/utils/matrix_add_block.html" class="code" title="function M = matrix_add_block(A,B);">matrix_add_block</a>(MW_reg,W_reg);
0364   MW_average = [MW_average, 1/nr * W_reg];
0365   <span class="keyword">end</span>
0366   MW_reg = [repmat(W_reg,nr+1,1), [zeros(length(tt),size(MW_reg,2)); MW_reg]];
0367 <span class="keyword">end</span>
0368 
0369 <span class="keyword">if</span> isfinite(options.t_smooth),
0370   MP         = MW         + 1/options.t_smooth * M        ;
0371   MP_reg     = MW_reg     + 1/options.t_smooth * M_reg    ;
0372   MP_average = MW_average + 1/options.t_smooth * M_average;
0373 <span class="keyword">end</span>
0374 
0375 <span class="comment">% -----------------------------------------------------</span>
0376 <span class="comment">% curve reconstruction (derivatives)</span>
0377 
0378 <span class="keyword">if</span> options.flag_time_derivative
0379 
0380   result.derivative.t = result.t;
0381 result.derivative.x_all                   = [ MW_reg * theta_posterior_mean ]';
0382 result.derivative.sigma_all               = sqrt(diag([ MW_reg * theta_posterior_cov * MW_reg']))';
0383 
0384 <span class="comment">% central curve and its uncertainty</span>
0385 result.derivative.x_central     = result.derivative.x_all(1:length(tt));
0386 result.derivative.sigma_central = result.derivative.sigma_all(1:length(tt));
0387 
0388 <span class="comment">% average curve and its uncertainty</span>
0389 result.derivative.x_average     = [MW_average * theta_posterior_mean]';
0390 
0391 <span class="keyword">switch</span> options.average_std,   
0392   <span class="keyword">case</span> <span class="string">'std_dev_mean'</span>,
0393     <span class="comment">%% consider the standard deviation of the mean:</span>
0394     result.derivative.sigma_average    = sqrt( diag( [ MW_average * theta_posterior_cov * MW_average'] ) )';
0395   <span class="keyword">case</span>  <span class="string">'curve_spread'</span>,
0396     <span class="comment">%% consider the standard deviation of the individual curves</span>
0397     result.derivative.sigma_average = std(reshape(result.derivative.x_all(length(tt)+1:end),length(tt),nr)');
0398 <span class="keyword">end</span>
0399 
0400 <span class="comment">% individual replicate curves</span>
0401 
0402 <span class="keyword">for</span> itt = 1:nr,
0403   result.derivative.x_replicate{itt} =  result.derivative.x_all(itt*length(tt)+(1:length(tt)));
0404   <span class="keyword">if</span> isempty( result.derivative.x_replicate{itt}),  
0405     result.derivative.x_replicate{itt} = nan * ones(1,length(tt)); 
0406     <span class="keyword">end</span>
0407   result.derivative.sigma_replicate{itt} =  result.derivative.sigma_all(itt*length(tt)+(1:length(tt)));
0408   <span class="keyword">if</span> isempty( result.derivative.sigma_replicate{itt}),  
0409     result.derivative.sigma_replicate{itt} = nan * ones(1,length(tt)); 
0410   <span class="keyword">end</span>
0411 <span class="keyword">end</span>
0412 
0413 <span class="keyword">end</span>
0414 
0415 <span class="comment">% -----------------------------------------------------</span>
0416 <span class="comment">% curve reconstruction (production rates)</span>
0417 
0418 <span class="keyword">if</span> isfinite(options.t_smooth),
0419 
0420   result.production.t = result.t;
0421   result.production.x_all                   = [ MP_reg * theta_posterior_mean ]';
0422   result.production.sigma_all               = sqrt(diag([ MP_reg * theta_posterior_cov * MP_reg']))';
0423   
0424 <span class="comment">% central curve and its uncertainty</span>
0425 result.production.x_central     = result.production.x_all(1:length(tt));
0426 result.production.sigma_central = result.production.sigma_all(1:length(tt));
0427 
0428 <span class="comment">% average curve and its uncertainty</span>
0429 result.production.x_average     = [MP_average * theta_posterior_mean]';
0430 
0431 <span class="keyword">switch</span> options.average_std,
0432   <span class="keyword">case</span> <span class="string">'std_dev_mean'</span>,
0433     <span class="comment">%% consider the standard deviation of the mean:</span>
0434     result.production.sigma_average    = sqrt( diag( [ MP_average * theta_posterior_cov * MP_average'] ) )';
0435   <span class="keyword">case</span>  <span class="string">'curve_spread'</span>,
0436     <span class="comment">%% consider the standard deviation of the individual curves</span>
0437     result.production.sigma_average = std(reshape(result.production.x_all(length(tt)+1:end),length(tt),nr)');
0438 <span class="keyword">end</span>
0439 
0440 <span class="comment">% individual replicate curves</span>
0441 
0442 <span class="keyword">for</span> itt = 1:nr,
0443   result.production.x_replicate{itt} =  result.production.x_all(itt*length(tt)+(1:length(tt)));
0444   <span class="keyword">if</span> isempty( result.production.x_replicate{itt}),  
0445     result.production.x_replicate{itt} = nan * ones(1,length(tt)); 
0446     <span class="keyword">end</span>
0447   result.production.sigma_replicate{itt} =  result.production.sigma_all(itt*length(tt)+(1:length(tt)));
0448   <span class="keyword">if</span> isempty( result.production.sigma_replicate{itt}),  
0449     result.production.sigma_replicate{itt} = nan * ones(1,length(tt)); 
0450   <span class="keyword">end</span>
0451 <span class="keyword">end</span>
0452 
0453 <span class="keyword">end</span>
0454 
0455 parameters.basis_functions.basis = options.basis;
0456 parameters.basis_functions.t     = t;
0457 parameters.basis_functions.V     = V;
0458 parameters.basis_functions.W     = W;
0459 parameters.basis_functions.t_reg = tt;
0460 parameters.basis_functions.V_reg = V_reg;
0461 parameters.basis_functions.W_reg = W_reg;
0462</pre></div>
<hr><address>Generated on Fri 13-Feb-2015 15:49:33 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>